/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: configs.proto */

#ifndef PROTOBUF_C_configs_2eproto__INCLUDED
#define PROTOBUF_C_configs_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _EnbConfigRequest EnbConfigRequest;
typedef struct _UeConfigRequest UeConfigRequest;
typedef struct _SgInfoMsg SgInfoMsg;
typedef struct _SgInfoConfig SgInfoConfig;
typedef struct _CellPhyConfig CellPhyConfig;
typedef struct _CellMacConfig CellMacConfig;
typedef struct _CellRrcConfig CellRrcConfig;
typedef struct _CellConfig CellConfig;
typedef struct _EnbConfigReply EnbConfigReply;
typedef struct _DrxConfig DrxConfig;
typedef struct _SpsConfig SpsConfig;
typedef struct _SrConfig SrConfig;
typedef struct _CqiConfig CqiConfig;
typedef struct _UeCapabilities UeCapabilities;
typedef struct _ScellConfig ScellConfig;
typedef struct _UePhyConfig UePhyConfig;
typedef struct _UeMacConfig UeMacConfig;
typedef struct _UeRrcConfig UeRrcConfig;
typedef struct _UeConfig UeConfig;
typedef struct _UeConfigReply UeConfigReply;
typedef struct _Configs Configs;


/* --- enums --- */

/*
 * Types of configuration related messages requested/sent by the controller.
 */
typedef enum _ConfigMsgType {
  /*
   * eNB configuration request.
   */
  CONFIG_MSG_TYPE__ENB_CONF_REQUEST = 0,
  /*
   * eNB configuration reply.
   */
  CONFIG_MSG_TYPE__ENB_CONF_REPLY = 1,
  /*
   * UE configuration request.
   */
  CONFIG_MSG_TYPE__UE_CONF_REQUEST = 2,
  /*
   * UE configuration reply.
   */
  CONFIG_MSG_TYPE__UE_CONF_REPLY = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CONFIG_MSG_TYPE)
} ConfigMsgType;
/*
 * Types of frequency hopping modes in the LTE.
 */
typedef enum _HoppingMode {
  /*
   * Inter subframe hopping.
   */
  HOPPING_MODE__HM_INTER = 0,
  /*
   * Intra subframe hopping.
   */
  HOPPING_MODE__HM_INTERINTRA = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(HOPPING_MODE)
} HoppingMode;
/*
 * Amount of PHICH resource used.
 */
typedef enum _PhichResource {
  /*
   * One-sixth.
   */
  PHICH_RESOURCE__PR_ONE_SIXTH = 0,
  /*
   * Half.
   */
  PHICH_RESOURCE__PR_HALF = 1,
  /*
   * One.
   */
  PHICH_RESOURCE__PR_ONE = 2,
  /*
   * Two.
   */
  PHICH_RESOURCE__PR_TWO = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PHICH_RESOURCE)
} PhichResource;
/*
 * Type of cyclic prefix, which help in PHICH duration determination.
 */
typedef enum _PhichDuration {
  /*
   * PHICH duration for Normal cyclic prefix.
   */
  PHICH_DURATION__PHICH_DUR_NORMAL = 0,
  /*
   * PHICH duration for Extended cyclic prefix.
   */
  PHICH_DURATION__PHICH_DUR_EXTENDED = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PHICH_DURATION)
} PhichDuration;
/*
 * Type of cyclic prefix used in uplink.
 */
typedef enum _UlCyclicPrefixLength {
  /*
   * Normal cyclic prefix.
   */
  UL_CYCLIC_PREFIX_LENGTH__UL_PREFIX_NORMAL = 0,
  /*
   * Extended cyclic prefix.
   */
  UL_CYCLIC_PREFIX_LENGTH__UL_PREFIX_EXTENDED = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(UL_CYCLIC_PREFIX_LENGTH)
} UlCyclicPrefixLength;
/*
 * Type of cyclic prefix used in downlink.
 */
typedef enum _DlCyclicPrefixLength {
  /*
   * Normal cyclic prefix.
   */
  DL_CYCLIC_PREFIX_LENGTH__DL_PREFIX_NORMAL = 0,
  /*
   * Extended cyclic prefix.
   */
  DL_CYCLIC_PREFIX_LENGTH__DL_PREFIX_EXTENDED = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(DL_CYCLIC_PREFIX_LENGTH)
} DlCyclicPrefixLength;
/*
 * Type of duplex mode used.
 */
typedef enum _DuplexMode {
  /*
   * Time Division Duplex (TDD).
   */
  DUPLEX_MODE__DM_TDD = 0,
  /*
   * Frequency Division Duplex (FDD).
   */
  DUPLEX_MODE__DM_FDD = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(DUPLEX_MODE)
} DuplexMode;
/*
 * Type of QAM mode used.
 */
typedef enum _Qam {
  /*
   * 16 Qaudrature Amplitude Modulation.
   */
  QAM__MOD_16QAM = 0,
  /*
   * 64 Qaudrature Amplitude Modulation.
   */
  QAM__MOD_64QAM = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(QAM)
} Qam;
/*
 * Types of measurement gap pattern configured in RRC.
 */
typedef enum _MeasGapPattern {
  MEAS_GAP_PATTERN__MGP_GP0 = 0,
  MEAS_GAP_PATTERN__MGP_GP1 = 1,
  MEAS_GAP_PATTERN__MGP_OFF = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(MEAS_GAP_PATTERN)
} MeasGapPattern;
/*
 * Types of operations, which are required for configuring Scheduling Request 
 * and CQI.
 */
typedef enum _SetupReleaseAction {
  SETUP_RELEASE_ACTION__SRA_SETUP = 0,
  SETUP_RELEASE_ACTION__SRA_RELEASE = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SETUP_RELEASE_ACTION)
} SetupReleaseAction;
/*
 * Types of UE transmission antenna. Related to power control.
 */
typedef enum _UeTransmissionAntenna {
  UE_TRANSMISSION_ANTENNA__UETA_NONE = 0,
  UE_TRANSMISSION_ANTENNA__UETA_OPEN_LOOP = 1,
  UE_TRANSMISSION_ANTENNA__UETA_CLOSED_LOOP = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(UE_TRANSMISSION_ANTENNA)
} UeTransmissionAntenna;
/*
 * Types of aperiodic CQI reporting mode.
 */
typedef enum _AperiodicCqiReportMode {
  APERIODIC_CQI_REPORT_MODE__ACRM_RM12 = 0,
  APERIODIC_CQI_REPORT_MODE__ACRM_RM20 = 1,
  APERIODIC_CQI_REPORT_MODE__ACRM_RM22 = 2,
  APERIODIC_CQI_REPORT_MODE__ACRM_RM30 = 3,
  APERIODIC_CQI_REPORT_MODE__ACRM_RM31 = 4,
  APERIODIC_CQI_REPORT_MODE__ACRM_NONE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(APERIODIC_CQI_REPORT_MODE)
} AperiodicCqiReportMode;
/*
 * Types of ACK/NACK feedback mode in TDD.
 */
typedef enum _TddAckNackFeedbackMode {
  TDD_ACK_NACK_FEEDBACK_MODE__TANFM_BUNDLING = 0,
  TDD_ACK_NACK_FEEDBACK_MODE__TANFM_MULTIPLEXING = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TDD_ACK_NACK_FEEDBACK_MODE)
} TddAckNackFeedbackMode;
/*
 * Configuration of different layers that could be requested by the controller.
 */
typedef enum _LayerConfig {
  /*
   * Configuration of all layers.
   */
  LAYER_CONFIG__LC_ALL = 1,
  /*
   * Configuration of PHY layer related parameters.
   */
  LAYER_CONFIG__LC_PHY = 2,
  /*
   * Configuration of MAC layer related parameters.
   */
  LAYER_CONFIG__LC_MAC = 4,
  /*
   * Configuration of RRC layer related parameters.
   */
  LAYER_CONFIG__LC_RRC = 8
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(LAYER_CONFIG)
} LayerConfig;

/* --- messages --- */

/*
 * Message definition for request of eNB configuration.
 */
struct  _EnbConfigRequest
{
  ProtobufCMessage base;
  /*
   * Configuration of different layers.
   * Bitmap of "layer_config" type.
   */
  protobuf_c_boolean has_layer;
  uint32_t layer;
  /*
   * List of CC (Component Carrier) ids for which configuration are needed.
   * Leave it empty to request all cc ids configuraiton.
   */
  size_t n_cc_id;
  uint32_t *cc_id;
};
#define ENB_CONFIG_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&enb_config_request__descriptor) \
    , 0,0, 0,NULL }


/*
 * Message definition for request of UEs configuration.
 */
struct  _UeConfigRequest
{
  ProtobufCMessage base;
  /*
   * Configuration of different layers.
   * Bitmap of "layer_config" type.
   */
  protobuf_c_boolean has_layer;
  uint32_t layer;
  /*
   * List of RNTIs of UEs for which configuration are needed.
   * Radio Network Temporary Identifier (RNTI).
   * Leave it empty to request all UEs configuration.
   */
  size_t n_rnti;
  uint32_t *rnti;
};
#define UE_CONFIG_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ue_config_request__descriptor) \
    , 0,0, 0,NULL }


/*
 * Message definition for configuration of signalling information (SI) messages.
 */
struct  _SgInfoMsg
{
  ProtobufCMessage base;
  /*
   * Periodicity of SI message in radio frames.
   */
  protobuf_c_boolean has_periodicity;
  uint32_t periodicity;
  /*
   * The length of the SI message in bytes.
   */
  protobuf_c_boolean has_length;
  uint32_t length;
};
#define SG_INFO_MSG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&sg_info_msg__descriptor) \
    , 0,0, 0,0 }


/*
 * Message definition for configuration of signalling information.
 */
struct  _SgInfoConfig
{
  ProtobufCMessage base;
  /*
   * System Frame number.
   */
  protobuf_c_boolean has_sfn;
  uint32_t sfn;
  /*
   * Length of Signalling Information Block 1 in bytes.
   */
  protobuf_c_boolean has_sib1_len;
  uint32_t sib1_len;
  /*
   * Scheduling window for all SIs in subframes.
   */
  protobuf_c_boolean has_si_window_len;
  uint32_t si_window_len;
  /*
   * List of SI messages to be sent.
   * The index of the lilst identifies the type of an SI message.
   * 0 - SIB1
   * 1..31 - SIx
   * 32..63 - PCCH
   */
  size_t n_si_message;
  SgInfoMsg **si_message;
};
#define SG_INFO_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&sg_info_config__descriptor) \
    , 0,0, 0,0, 0,0, 0,NULL }


/*
 * Message definition for physical layer related configuration of a cell.
 */
struct  _CellPhyConfig
{
  ProtobufCMessage base;
  /*
   * Physical cell id of this cell.
   */
  protobuf_c_boolean has_pci;
  uint32_t pci;
  /*
   * PLMN cell id of this cell.
   */
  protobuf_c_boolean has_cell_id;
  uint32_t cell_id;
  /*
   * PUSCH resources in RBs for hopping.
   * PUSCH = Physical Uplink Shared channel.
   * RB = Resource block.
   */
  protobuf_c_boolean has_pusch_hopp_offset;
  uint32_t pusch_hopp_offset;
  /*
   * Type of hopping mode used.
   */
  protobuf_c_boolean has_hopp_mode;
  HoppingMode hopp_mode;
  /*
   * Number of subbands.
   */
  protobuf_c_boolean has_n_sb;
  uint32_t n_sb;
  /*
   * Number of REGs used for PHICH.
   * Resource Element Group (REG). 1 REG = 4 Resource Elements (RE)
   * Physical channel HybridARQ Indicator Channel (PHICH).
   */
  protobuf_c_boolean has_phich_res;
  PhichResource phich_res;
  /*
   * PHICH duration used.
   */
  protobuf_c_boolean has_phich_dur;
  PhichDuration phich_dur;
  /*
   * Number of OFDM symbols possible to use for PDCCH in a subframe.
   * Refer TS 36.211, section 6.9.
   */
  protobuf_c_boolean has_init_nr_pdcch_ofdm_sym;
  uint32_t init_nr_pdcch_ofdm_sym;
  /*
   * Signalling Information (SI) configuration.
   */
  SgInfoConfig *si_conf;
  /*
   * Downlink transmission bandwidth in RBs.
   */
  protobuf_c_boolean has_dl_bw;
  uint32_t dl_bw;
  /*
   * Uplink transmission bandwidth in RBs.
   */
  protobuf_c_boolean has_ul_bw;
  uint32_t ul_bw;
  /*
   * Cyclic prefix length used in uplink.
   */
  protobuf_c_boolean has_ul_cyc_prefix_len;
  UlCyclicPrefixLength ul_cyc_prefix_len;
  /*
   * Cyclic prefix length used in downlink.
   */
  protobuf_c_boolean has_dl_cyc_prefix_len;
  DlCyclicPrefixLength dl_cyc_prefix_len;
  /*
   * Number of cell specific antenna ports.
   */
  protobuf_c_boolean has_antenna_ports_count;
  uint32_t antenna_ports_count;
  /*
   * Type of duplex mode used.
   */
  protobuf_c_boolean has_dupl_mode;
  DuplexMode dupl_mode;
  /*
   * Physical Random Access Channel (PRACH) configuration index.
   * Refer TS 36.211, section 5.7.1.
   */
  protobuf_c_boolean has_prach_conf_index;
  uint32_t prach_conf_index;
  /*
   * Physical Random Access Channel (PRACH) frequency offset.
   * Refer TS 36.211, section 5.7.1.
   */
  protobuf_c_boolean has_prach_freq_offset;
  uint32_t prach_freq_offset;
  /*
   * The duration of the Random Access (RA) response window in subframes.
   */
  protobuf_c_boolean has_ra_resp_window_size;
  uint32_t ra_resp_window_size;
  /*
   * Resource index for ACK/NACK.
   * Refer TS 36.213, section 10.1.
   */
  protobuf_c_boolean has_n1pucch_an;
  uint32_t n1pucch_an;
  /*
   * Number of equally spaced cyclic time shifts.
   * Refer TS 36.211, section 5.4.
   */
  protobuf_c_boolean has_deltapucch_shift;
  uint32_t deltapucch_shift;
  /*
   * 64 QAM is enabled or not.
   */
  protobuf_c_boolean has_enable_64qam;
  Qam enable_64qam;
};
#define CELL_PHY_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cell_phy_config__descriptor) \
    , 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, NULL, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }


/*
 * Message definition for MAC layer related configuration of a cell.
 */
struct  _CellMacConfig
{
  ProtobufCMessage base;
  /*
   * DL/UL subframe assignment. TDD only.
   */
  protobuf_c_boolean has_sf_assign;
  uint32_t sf_assign;
  /*
   * Special subframe pattern. TDD only. Refer TS 36.211, table 4.2.1.
   */
  protobuf_c_boolean has_special_subframe_patterns;
  uint32_t special_subframe_patterns;
  /*
   * Timer for RA. MAC contention resolution timer.
   */
  protobuf_c_boolean has_mac_cont_resol_timer;
  uint32_t mac_cont_resol_timer;
  /*
   * Maximum Hybrid ARQ for Msg3 transmission. Refer TS 36.321.
   */
  protobuf_c_boolean has_max_harq_msg3tx;
  uint32_t max_harq_msg3tx;
  /*
   * n Resource Blocks CQI. Refer TS 36.211, section 5.4.
   */
  protobuf_c_boolean has_nrb_cqi;
  uint32_t nrb_cqi;
};
#define CELL_MAC_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cell_mac_config__descriptor) \
    , 0,0, 0,0, 0,0, 0,0, 0,0 }


/*
 * Message definition for RRC layer related configuration of a cell.
 */
struct  _CellRrcConfig
{
  ProtobufCMessage base;
  /*
   * Radio Frame meeting the following equation is allocated for MBSFN.
   * SFN mod radioframeAllocationPeriod = radioframeAllocationOffset
   * Configuration of MBSFN radio frame period in SIB2.
   * Multimedia Broadcast Single Frequency network (MBSFN)
   */
  size_t n_mbsfn_conf_rfperiod;
  uint32_t *mbsfn_conf_rfperiod;
  /*
   * Configuration of MBSFN radio frame offset in SIB2.
   */
  size_t n_mbsfn_conf_rfoffset;
  uint32_t *mbsfn_conf_rfoffset;
  /*
   * Bitmap indicating subframes that are allocated for MBSFN 
   * within the MBSFN frame.
   */
  size_t n_mbsfn_conf_sfalloc;
  uint32_t *mbsfn_conf_sfalloc;
  /*
   * SRS subframe configuration in SIB2. Refer TS 36.211, table 5.5.3.3-1 & 2.
   * Sounding Reference Signal (SRS).
   */
  protobuf_c_boolean has_srs_sf_conf;
  uint32_t srs_sf_conf;
  /*
   * SRS bandwidth configuration in SIB2. Refer TS 36.211, section 5.5.3.2.
   */
  protobuf_c_boolean has_srs_bw_conf;
  uint32_t srs_bw_conf;
  /*
   * SRS maximum uplink pilot time slot.
   * Boolean value. Refer TS 36.211, section 5.5.3.2. TDD only
   */
  protobuf_c_boolean has_srs_max_up_pts;
  uint32_t srs_max_up_pts;
};
#define CELL_RRC_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cell_rrc_config__descriptor) \
    , 0,NULL, 0,NULL, 0,NULL, 0,0, 0,0, 0,0 }


/*
 * Message definition for cell configuration in an eNB.
 */
struct  _CellConfig
{
  ProtobufCMessage base;
  /*
   * Component Carrier (CC) index.
   */
  protobuf_c_boolean has_cc_id;
  uint32_t cc_id;
  /*
   * Physical layer related configuration of the cell.
   */
  CellPhyConfig *phy_conf;
  /*
   * MAC layer related configuration of the cell.
   */
  CellMacConfig *mac_conf;
  /*
   * RRC layer related configuration of the cell.
   */
  CellRrcConfig *rrc_conf;
};
#define CELL_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cell_config__descriptor) \
    , 0,0, NULL, NULL, NULL }


/*
 * Message definition of reply for eNB configuration request.
 */
struct  _EnbConfigReply
{
  ProtobufCMessage base;
  /*
   * List of configuraiton of all or requested cells.
   */
  size_t n_cell_conf;
  CellConfig **cell_conf;
};
#define ENB_CONFIG_REPLY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&enb_config_reply__descriptor) \
    , 0,NULL }


/*
 * Message definition for configuration of discontinuos reception in RRC.
 */
struct  _DrxConfig
{
  ProtobufCMessage base;
  /*
   * Duration of 'ON time' within one DRX cycle in subframes.
   * Refer TS 36.321.
   */
  protobuf_c_boolean has_on_dur_timer;
  uint32_t on_dur_timer;
  /*
   * Time in subframes for how long UE should remain 'ON' after 
   * the reception of a PDCCH. Refer TS 36.321.
   */
  protobuf_c_boolean has_drx_inact_timer;
  uint32_t drx_inact_timer;
  /*
   * Time in subframes, maximum number of consecutive PDCCH subframes the UE 
   * should remain active to wait an incoming retransmission. Refer TS 36.321.
   */
  protobuf_c_boolean has_drx_retrx_timer;
  uint32_t drx_retrx_timer;
  /*
   * Long DRX cycle. Specified in subframes. Refer TS 36.321.
   */
  protobuf_c_boolean has_long_drx_cycle;
  uint32_t long_drx_cycle;
  /*
   * Long DRX start offset. Used to calculate DRX cycle. Refer TS 36.321.
   */
  protobuf_c_boolean has_long_drx_cycle_start_offset;
  uint32_t long_drx_cycle_start_offset;
  /*
   * DRX cycle which can be implemented within the 'OFF' period of a 
   * long DRX Cycle. Specified in subframes.
   */
  protobuf_c_boolean has_short_drx_cycle;
  uint32_t short_drx_cycle;
  /*
   * The consecutive number of subframes the UE shall follow the short DRX
   * cycle after the DRX Inactivity Timer has expired. Specified in subframes.
   */
  protobuf_c_boolean has_drx_short_cycle_timer;
  uint32_t drx_short_cycle_timer;
};
#define DRX_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&drx_config__descriptor) \
    , 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }


/*
 * Message definition for configuration of semi-persistent scheduling in RRC.
 */
struct  _SpsConfig
{
  ProtobufCMessage base;
  /*
   * SPS UL scheduling interval in subframes.
   * SPS = Semi-Persistent Scheduling.
   */
  protobuf_c_boolean has_sps_interval_ul;
  uint32_t sps_interval_ul;
  /*
   * SPS DL scheduling interval in subframes.
   */
  protobuf_c_boolean has_sps_interval_dl;
  uint32_t sps_interval_dl;
  /*
   * Number of SPS HARQ processes. Refer TS 36.321.
   */
  protobuf_c_boolean has_n_conf_sps_proc;
  uint32_t n_conf_sps_proc;
  /*
   * Index to one of the four PUCCH resource values. Refer TS 36.213.
   */
  size_t n_n1_pucch_an_persistent_element;
  uint32_t *n1_pucch_an_persistent_element;
  /*
   * Number of empty transmissions before release of SPS.
   */
  protobuf_c_boolean has_implicit_release_after;
  uint32_t implicit_release_after;
};
#define SPS_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&sps_config__descriptor) \
    , 0,0, 0,0, 0,0, 0,NULL, 0,0 }


/*
 * Message definition for configuration of SR (Scheduling Request) in MAC.
 */
struct  _SrConfig
{
  ProtobufCMessage base;
  /*
   * Indicates if SR config should be changed or released.
   */
  protobuf_c_boolean has_sr_action;
  SetupReleaseAction sr_action;
  /*
   * SR scheduling interval in subframes.
   */
  protobuf_c_boolean has_sched_inter;
  uint32_t sched_inter;
  /*
   * Maximum number of SR transmission count. Refer 36.321 5.4.4 SR.		
   */
  protobuf_c_boolean has_dsr_trans_max;
  uint32_t dsr_trans_max;
};
#define SR_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&sr_config__descriptor) \
    , 0,0, 0,0, 0,0 }


/*
 * Message definition for configuration of CQI in RRC.
 */
struct  _CqiConfig
{
  ProtobufCMessage base;
  /*
   * Indicats if CQI changed or released.
   */
  protobuf_c_boolean has_cqi_action;
  SetupReleaseAction cqi_action;
  /*
   * CQI scheduling interval in subframes.
   */
  protobuf_c_boolean has_cqi_sched_inter;
  uint32_t cqi_sched_inter;
  /*
   * Rank Indication scheduling interval in subframes.
   */
  protobuf_c_boolean has_ri_sched_inter;
  uint32_t ri_sched_inter;
};
#define CQI_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cqi_config__descriptor) \
    , 0,0, 0,0, 0,0 }


/*
 * Message definition for UE capabilities.
 */
struct  _UeCapabilities
{
  ProtobufCMessage base;
  /*
   * Boolean value. Only half duplex support. FDD operation
   */
  protobuf_c_boolean has_half_duplex;
  uint32_t half_duplex;
  /*
   * Boolean value. Support for intra-subframe hopping.
   */
  protobuf_c_boolean has_intra_sf_hopping;
  uint32_t intra_sf_hopping;
  /*
   * Support for type 2 hopping with n_sb > 1
   */
  protobuf_c_boolean has_type2_sb_1;
  uint32_t type2_sb_1;
  /*
   * Category of the UE.
   */
  protobuf_c_boolean has_ue_category;
  uint32_t ue_category;
  /*
   * Boolean value. UE support for resource allocation type 1.
   */
  protobuf_c_boolean has_res_alloc_type1;
  uint32_t res_alloc_type1;
};
#define UE_CAPABILITIES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ue_capabilities__descriptor) \
    , 0,0, 0,0, 0,0, 0,0, 0,0 }


/*
 * Message definition for Secondary Cell (SCell) configuration.
 */
struct  _ScellConfig
{
  ProtobufCMessage base;
  /*
   * Component Carrier identifier.
   */
  protobuf_c_boolean has_cc_id;
  uint32_t cc_id;
  /*
   * Index of this Scell (RRC SCellIndex)
   */
  protobuf_c_boolean has_scell_index;
  uint32_t scell_index;
  /*
   * Boolean value. Indicates if cross-carrier scheduling is used 
   * by this SCell.
   */
  protobuf_c_boolean has_use_ccs;
  uint32_t use_ccs;
  /*
   * Index of the cell responsible for scheduling this SCell if 
   * cross-carrier scheduling is enabled.
   */
  protobuf_c_boolean has_sched_cell_index;
  uint32_t sched_cell_index;
  /*
   * Start of OFDM symbol of PDSCH data region for this SCell.
   */
  protobuf_c_boolean has_pdsch_start;
  uint32_t pdsch_start;
};
#define SCELL_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&scell_config__descriptor) \
    , 0,0, 0,0, 0,0, 0,0, 0,0 }


/*
 * Message definition for physical layer related configuration of a UE.
 */
struct  _UePhyConfig
{
  ProtobufCMessage base;
  /*
   * Scheduling Request configuration.
   */
  SrConfig *sr_conf;
  /*
   * Transmission mode 1 (single antenna), 2 (transmit diversity), etc.
   */
  protobuf_c_boolean has_transmission_mode;
  uint32_t transmission_mode;
  /*
   * UE transmission antenna type. Related to power control.
   */
  protobuf_c_boolean has_ue_trx_antenna;
  UeTransmissionAntenna ue_trx_antenna;
};
#define UE_PHY_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ue_phy_config__descriptor) \
    , NULL, 0,0, 0,0 }


/*
 * Message definition for MAC layer related configuration of a UE.
 */
struct  _UeMacConfig
{
  ProtobufCMessage base;
  /*
   * Timer in SF. Control the synchronization status of the UE, not the 
   * actual advance procedure. Refer TS 36.321.
   */
  protobuf_c_boolean has_time_alignment_timer;
  uint32_t time_alignment_timer;
  /*
   * Boolean value. Transmission Time Interval bundling enable or disable.
   */
  protobuf_c_boolean has_tti_bundling;
  uint32_t tti_bundling;
  /*
   * Maximum HARQ retransmission for UL.
   */
  protobuf_c_boolean has_max_harq_tx;
  uint32_t max_harq_tx;
  /*
   * Boolean value. Refer TS 36.213
   */
  protobuf_c_boolean has_ack_nack_simultaneous_trans;
  uint32_t ack_nack_simultaneous_trans;
  /*
   * Boolean value. Refer TS 36.213
   */
  protobuf_c_boolean has_simultaneous_ack_nack_cqi;
  uint32_t simultaneous_ack_nack_cqi;
  /*
   * Types of aperiodic CQI reporting mode.
   */
  protobuf_c_boolean has_aper_cqi_rep;
  AperiodicCqiReportMode aper_cqi_rep;
};
#define UE_MAC_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ue_mac_config__descriptor) \
    , 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }


/*
 * Message definition for RRC layer related configuration of a UE.
 */
struct  _UeRrcConfig
{
  ProtobufCMessage base;
  /*
   * Discontinuos reception (DRX) configuration.
   */
  DrxConfig *drx_conf;
  /*
   * Measurement gap configuration. Refer TS 36.133.
   */
  protobuf_c_boolean has_meas_gap_patt;
  MeasGapPattern meas_gap_patt;
  /*
   * Measurement gap offset if measurement gap is configured.
   */
  protobuf_c_boolean has_meas_gap_config_sf_offset;
  uint32_t meas_gap_config_sf_offset;
  /*
   * Semi-Persistent Scheduling configuration.
   */
  SpsConfig *sps_conf;
  /*
   * CQI configuration (Optional)
   */
  CqiConfig *cqi_conf;
  /*
   * Aggregated bit-rate of non-gbr bearer per UE. Refer TS 36.413.
   */
  protobuf_c_boolean has_ue_aggreg_max_bitrate_ul;
  uint64_t ue_aggreg_max_bitrate_ul;
  /*
   * Aggregated bit-rate of non-gbr bearer per UE. Refer TS 36.413.
   */
  protobuf_c_boolean has_ue_aggreg_max_bitrate_dl;
  uint64_t ue_aggreg_max_bitrate_dl;
  /*
   * UE capabilities information.
   */
  UeCapabilities *capabilities;
  /*
   * Offset index value for HARQ-ACK. Refer TS 36.213.
   */
  protobuf_c_boolean has_beta_offset_ack_index;
  uint32_t beta_offset_ack_index;
  /*
   * Offset index value for Rank Indication. Refer TS 36.213.
   */
  protobuf_c_boolean has_beta_offset_ri_index;
  uint32_t beta_offset_ri_index;
  /*
   * Offset index value for CQI. Refer TS 36.213.
   */
  protobuf_c_boolean has_beta_offset_cqi_index;
  uint32_t beta_offset_cqi_index;
  /*
   * Secondary cells configurations.
   */
  size_t n_scell_conf;
  ScellConfig **scell_conf;
  /*
   * Deactivation timer for secondary cell.
   */
  protobuf_c_boolean has_scell_deactivation_timer;
  uint32_t scell_deactivation_timer;
  /*
   * Type of ACK/NACK feedback mode in TDD.
   */
  protobuf_c_boolean has_tdd_ack_nack_feedb;
  TddAckNackFeedbackMode tdd_ack_nack_feedb;
  /*
   * Repition factor set for ACK/NACK. Refer TS 36.213, section 10.1.
   */
  protobuf_c_boolean has_ack_nack_rep_factor;
  uint32_t ack_nack_rep_factor;
  /*
   * Boolean value. Extended BSR size enable or disable.
   */
  protobuf_c_boolean has_extended_bsr_size;
  uint32_t extended_bsr_size;
  /*
   * Boolean value. Support for carrier aggregation
   */
  protobuf_c_boolean has_ca_support;
  uint32_t ca_support;
  /*
   * Boolean value. Support for cross carrier scheduling.
   */
  protobuf_c_boolean has_cross_carrier_sched_supp;
  uint32_t cross_carrier_sched_supp;
  /*
   * Component Carrier id of primary cell.
   */
  protobuf_c_boolean has_pcell_cc_id;
  uint32_t pcell_cc_id;
};
#define UE_RRC_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ue_rrc_config__descriptor) \
    , NULL, 0,0, 0,0, NULL, NULL, 0,0, 0,0, NULL, 0,0, 0,0, 0,0, 0,NULL, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }


/*
 * Message definition for UE configuration.
 */
struct  _UeConfig
{
  ProtobufCMessage base;
  /*
   * RNTIs of UE for which configuration are needed.
   */
  protobuf_c_boolean has_rnti;
  uint32_t rnti;
  /*
   * Physical layer related configuration of the UE.
   */
  UePhyConfig *phy_conf;
  /*
   * MAC layer related configuration of the UE.
   */
  UeMacConfig *mac_conf;
  /*
   * RRC layer related configuration of the UE.
   */
  UeRrcConfig *rrc_conf;
};
#define UE_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ue_config__descriptor) \
    , 0,0, NULL, NULL, NULL }


/*
 * Message definition of reply for UE configuration request.
 */
struct  _UeConfigReply
{
  ProtobufCMessage base;
  /*
   * List of configuraiton of all or requested UEs.
   */
  size_t n_ue_conf;
  UeConfig **ue_conf;
};
#define UE_CONFIG_REPLY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ue_config_reply__descriptor) \
    , 0,NULL }


typedef enum {
  CONFIGS__CONFIG_MSG__NOT_SET = 0,
  CONFIGS__CONFIG_MSG_ENB_CONF_REQ = 1,
  CONFIGS__CONFIG_MSG_ENB_CONF_REPL = 2,
  CONFIGS__CONFIG_MSG_UE_CONF_REQ = 3,
  CONFIGS__CONFIG_MSG_UE_CONF_REPL = 4,
} Configs__ConfigMsgCase;

/*
 * Common configurations message to identify the type of configurations.
 */
struct  _Configs
{
  ProtobufCMessage base;
  /*
   * Type of 2nd level message.
   */
  protobuf_c_boolean has_type;
  ConfigMsgType type;
  Configs__ConfigMsgCase config_msg_case;
  union {
    /*
     * Request message for eNB configuration.
     */
    EnbConfigRequest *enb_conf_req;
    /*
     * Reply message with eNB configuration.
     */
    EnbConfigReply *enb_conf_repl;
    /*
     * Request message for UEs configuration.
     */
    UeConfigRequest *ue_conf_req;
    /*
     * Reply message with UEs configuration.
     */
    UeConfigReply *ue_conf_repl;
  };
};
#define CONFIGS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&configs__descriptor) \
    , 0,0, CONFIGS__CONFIG_MSG__NOT_SET, {0} }


/* EnbConfigRequest methods */
void   enb_config_request__init
                     (EnbConfigRequest         *message);
size_t enb_config_request__get_packed_size
                     (const EnbConfigRequest   *message);
size_t enb_config_request__pack
                     (const EnbConfigRequest   *message,
                      uint8_t             *out);
size_t enb_config_request__pack_to_buffer
                     (const EnbConfigRequest   *message,
                      ProtobufCBuffer     *buffer);
EnbConfigRequest *
       enb_config_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   enb_config_request__free_unpacked
                     (EnbConfigRequest *message,
                      ProtobufCAllocator *allocator);
/* UeConfigRequest methods */
void   ue_config_request__init
                     (UeConfigRequest         *message);
size_t ue_config_request__get_packed_size
                     (const UeConfigRequest   *message);
size_t ue_config_request__pack
                     (const UeConfigRequest   *message,
                      uint8_t             *out);
size_t ue_config_request__pack_to_buffer
                     (const UeConfigRequest   *message,
                      ProtobufCBuffer     *buffer);
UeConfigRequest *
       ue_config_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ue_config_request__free_unpacked
                     (UeConfigRequest *message,
                      ProtobufCAllocator *allocator);
/* SgInfoMsg methods */
void   sg_info_msg__init
                     (SgInfoMsg         *message);
size_t sg_info_msg__get_packed_size
                     (const SgInfoMsg   *message);
size_t sg_info_msg__pack
                     (const SgInfoMsg   *message,
                      uint8_t             *out);
size_t sg_info_msg__pack_to_buffer
                     (const SgInfoMsg   *message,
                      ProtobufCBuffer     *buffer);
SgInfoMsg *
       sg_info_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   sg_info_msg__free_unpacked
                     (SgInfoMsg *message,
                      ProtobufCAllocator *allocator);
/* SgInfoConfig methods */
void   sg_info_config__init
                     (SgInfoConfig         *message);
size_t sg_info_config__get_packed_size
                     (const SgInfoConfig   *message);
size_t sg_info_config__pack
                     (const SgInfoConfig   *message,
                      uint8_t             *out);
size_t sg_info_config__pack_to_buffer
                     (const SgInfoConfig   *message,
                      ProtobufCBuffer     *buffer);
SgInfoConfig *
       sg_info_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   sg_info_config__free_unpacked
                     (SgInfoConfig *message,
                      ProtobufCAllocator *allocator);
/* CellPhyConfig methods */
void   cell_phy_config__init
                     (CellPhyConfig         *message);
size_t cell_phy_config__get_packed_size
                     (const CellPhyConfig   *message);
size_t cell_phy_config__pack
                     (const CellPhyConfig   *message,
                      uint8_t             *out);
size_t cell_phy_config__pack_to_buffer
                     (const CellPhyConfig   *message,
                      ProtobufCBuffer     *buffer);
CellPhyConfig *
       cell_phy_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cell_phy_config__free_unpacked
                     (CellPhyConfig *message,
                      ProtobufCAllocator *allocator);
/* CellMacConfig methods */
void   cell_mac_config__init
                     (CellMacConfig         *message);
size_t cell_mac_config__get_packed_size
                     (const CellMacConfig   *message);
size_t cell_mac_config__pack
                     (const CellMacConfig   *message,
                      uint8_t             *out);
size_t cell_mac_config__pack_to_buffer
                     (const CellMacConfig   *message,
                      ProtobufCBuffer     *buffer);
CellMacConfig *
       cell_mac_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cell_mac_config__free_unpacked
                     (CellMacConfig *message,
                      ProtobufCAllocator *allocator);
/* CellRrcConfig methods */
void   cell_rrc_config__init
                     (CellRrcConfig         *message);
size_t cell_rrc_config__get_packed_size
                     (const CellRrcConfig   *message);
size_t cell_rrc_config__pack
                     (const CellRrcConfig   *message,
                      uint8_t             *out);
size_t cell_rrc_config__pack_to_buffer
                     (const CellRrcConfig   *message,
                      ProtobufCBuffer     *buffer);
CellRrcConfig *
       cell_rrc_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cell_rrc_config__free_unpacked
                     (CellRrcConfig *message,
                      ProtobufCAllocator *allocator);
/* CellConfig methods */
void   cell_config__init
                     (CellConfig         *message);
size_t cell_config__get_packed_size
                     (const CellConfig   *message);
size_t cell_config__pack
                     (const CellConfig   *message,
                      uint8_t             *out);
size_t cell_config__pack_to_buffer
                     (const CellConfig   *message,
                      ProtobufCBuffer     *buffer);
CellConfig *
       cell_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cell_config__free_unpacked
                     (CellConfig *message,
                      ProtobufCAllocator *allocator);
/* EnbConfigReply methods */
void   enb_config_reply__init
                     (EnbConfigReply         *message);
size_t enb_config_reply__get_packed_size
                     (const EnbConfigReply   *message);
size_t enb_config_reply__pack
                     (const EnbConfigReply   *message,
                      uint8_t             *out);
size_t enb_config_reply__pack_to_buffer
                     (const EnbConfigReply   *message,
                      ProtobufCBuffer     *buffer);
EnbConfigReply *
       enb_config_reply__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   enb_config_reply__free_unpacked
                     (EnbConfigReply *message,
                      ProtobufCAllocator *allocator);
/* DrxConfig methods */
void   drx_config__init
                     (DrxConfig         *message);
size_t drx_config__get_packed_size
                     (const DrxConfig   *message);
size_t drx_config__pack
                     (const DrxConfig   *message,
                      uint8_t             *out);
size_t drx_config__pack_to_buffer
                     (const DrxConfig   *message,
                      ProtobufCBuffer     *buffer);
DrxConfig *
       drx_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   drx_config__free_unpacked
                     (DrxConfig *message,
                      ProtobufCAllocator *allocator);
/* SpsConfig methods */
void   sps_config__init
                     (SpsConfig         *message);
size_t sps_config__get_packed_size
                     (const SpsConfig   *message);
size_t sps_config__pack
                     (const SpsConfig   *message,
                      uint8_t             *out);
size_t sps_config__pack_to_buffer
                     (const SpsConfig   *message,
                      ProtobufCBuffer     *buffer);
SpsConfig *
       sps_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   sps_config__free_unpacked
                     (SpsConfig *message,
                      ProtobufCAllocator *allocator);
/* SrConfig methods */
void   sr_config__init
                     (SrConfig         *message);
size_t sr_config__get_packed_size
                     (const SrConfig   *message);
size_t sr_config__pack
                     (const SrConfig   *message,
                      uint8_t             *out);
size_t sr_config__pack_to_buffer
                     (const SrConfig   *message,
                      ProtobufCBuffer     *buffer);
SrConfig *
       sr_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   sr_config__free_unpacked
                     (SrConfig *message,
                      ProtobufCAllocator *allocator);
/* CqiConfig methods */
void   cqi_config__init
                     (CqiConfig         *message);
size_t cqi_config__get_packed_size
                     (const CqiConfig   *message);
size_t cqi_config__pack
                     (const CqiConfig   *message,
                      uint8_t             *out);
size_t cqi_config__pack_to_buffer
                     (const CqiConfig   *message,
                      ProtobufCBuffer     *buffer);
CqiConfig *
       cqi_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cqi_config__free_unpacked
                     (CqiConfig *message,
                      ProtobufCAllocator *allocator);
/* UeCapabilities methods */
void   ue_capabilities__init
                     (UeCapabilities         *message);
size_t ue_capabilities__get_packed_size
                     (const UeCapabilities   *message);
size_t ue_capabilities__pack
                     (const UeCapabilities   *message,
                      uint8_t             *out);
size_t ue_capabilities__pack_to_buffer
                     (const UeCapabilities   *message,
                      ProtobufCBuffer     *buffer);
UeCapabilities *
       ue_capabilities__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ue_capabilities__free_unpacked
                     (UeCapabilities *message,
                      ProtobufCAllocator *allocator);
/* ScellConfig methods */
void   scell_config__init
                     (ScellConfig         *message);
size_t scell_config__get_packed_size
                     (const ScellConfig   *message);
size_t scell_config__pack
                     (const ScellConfig   *message,
                      uint8_t             *out);
size_t scell_config__pack_to_buffer
                     (const ScellConfig   *message,
                      ProtobufCBuffer     *buffer);
ScellConfig *
       scell_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   scell_config__free_unpacked
                     (ScellConfig *message,
                      ProtobufCAllocator *allocator);
/* UePhyConfig methods */
void   ue_phy_config__init
                     (UePhyConfig         *message);
size_t ue_phy_config__get_packed_size
                     (const UePhyConfig   *message);
size_t ue_phy_config__pack
                     (const UePhyConfig   *message,
                      uint8_t             *out);
size_t ue_phy_config__pack_to_buffer
                     (const UePhyConfig   *message,
                      ProtobufCBuffer     *buffer);
UePhyConfig *
       ue_phy_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ue_phy_config__free_unpacked
                     (UePhyConfig *message,
                      ProtobufCAllocator *allocator);
/* UeMacConfig methods */
void   ue_mac_config__init
                     (UeMacConfig         *message);
size_t ue_mac_config__get_packed_size
                     (const UeMacConfig   *message);
size_t ue_mac_config__pack
                     (const UeMacConfig   *message,
                      uint8_t             *out);
size_t ue_mac_config__pack_to_buffer
                     (const UeMacConfig   *message,
                      ProtobufCBuffer     *buffer);
UeMacConfig *
       ue_mac_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ue_mac_config__free_unpacked
                     (UeMacConfig *message,
                      ProtobufCAllocator *allocator);
/* UeRrcConfig methods */
void   ue_rrc_config__init
                     (UeRrcConfig         *message);
size_t ue_rrc_config__get_packed_size
                     (const UeRrcConfig   *message);
size_t ue_rrc_config__pack
                     (const UeRrcConfig   *message,
                      uint8_t             *out);
size_t ue_rrc_config__pack_to_buffer
                     (const UeRrcConfig   *message,
                      ProtobufCBuffer     *buffer);
UeRrcConfig *
       ue_rrc_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ue_rrc_config__free_unpacked
                     (UeRrcConfig *message,
                      ProtobufCAllocator *allocator);
/* UeConfig methods */
void   ue_config__init
                     (UeConfig         *message);
size_t ue_config__get_packed_size
                     (const UeConfig   *message);
size_t ue_config__pack
                     (const UeConfig   *message,
                      uint8_t             *out);
size_t ue_config__pack_to_buffer
                     (const UeConfig   *message,
                      ProtobufCBuffer     *buffer);
UeConfig *
       ue_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ue_config__free_unpacked
                     (UeConfig *message,
                      ProtobufCAllocator *allocator);
/* UeConfigReply methods */
void   ue_config_reply__init
                     (UeConfigReply         *message);
size_t ue_config_reply__get_packed_size
                     (const UeConfigReply   *message);
size_t ue_config_reply__pack
                     (const UeConfigReply   *message,
                      uint8_t             *out);
size_t ue_config_reply__pack_to_buffer
                     (const UeConfigReply   *message,
                      ProtobufCBuffer     *buffer);
UeConfigReply *
       ue_config_reply__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ue_config_reply__free_unpacked
                     (UeConfigReply *message,
                      ProtobufCAllocator *allocator);
/* Configs methods */
void   configs__init
                     (Configs         *message);
size_t configs__get_packed_size
                     (const Configs   *message);
size_t configs__pack
                     (const Configs   *message,
                      uint8_t             *out);
size_t configs__pack_to_buffer
                     (const Configs   *message,
                      ProtobufCBuffer     *buffer);
Configs *
       configs__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   configs__free_unpacked
                     (Configs *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*EnbConfigRequest_Closure)
                 (const EnbConfigRequest *message,
                  void *closure_data);
typedef void (*UeConfigRequest_Closure)
                 (const UeConfigRequest *message,
                  void *closure_data);
typedef void (*SgInfoMsg_Closure)
                 (const SgInfoMsg *message,
                  void *closure_data);
typedef void (*SgInfoConfig_Closure)
                 (const SgInfoConfig *message,
                  void *closure_data);
typedef void (*CellPhyConfig_Closure)
                 (const CellPhyConfig *message,
                  void *closure_data);
typedef void (*CellMacConfig_Closure)
                 (const CellMacConfig *message,
                  void *closure_data);
typedef void (*CellRrcConfig_Closure)
                 (const CellRrcConfig *message,
                  void *closure_data);
typedef void (*CellConfig_Closure)
                 (const CellConfig *message,
                  void *closure_data);
typedef void (*EnbConfigReply_Closure)
                 (const EnbConfigReply *message,
                  void *closure_data);
typedef void (*DrxConfig_Closure)
                 (const DrxConfig *message,
                  void *closure_data);
typedef void (*SpsConfig_Closure)
                 (const SpsConfig *message,
                  void *closure_data);
typedef void (*SrConfig_Closure)
                 (const SrConfig *message,
                  void *closure_data);
typedef void (*CqiConfig_Closure)
                 (const CqiConfig *message,
                  void *closure_data);
typedef void (*UeCapabilities_Closure)
                 (const UeCapabilities *message,
                  void *closure_data);
typedef void (*ScellConfig_Closure)
                 (const ScellConfig *message,
                  void *closure_data);
typedef void (*UePhyConfig_Closure)
                 (const UePhyConfig *message,
                  void *closure_data);
typedef void (*UeMacConfig_Closure)
                 (const UeMacConfig *message,
                  void *closure_data);
typedef void (*UeRrcConfig_Closure)
                 (const UeRrcConfig *message,
                  void *closure_data);
typedef void (*UeConfig_Closure)
                 (const UeConfig *message,
                  void *closure_data);
typedef void (*UeConfigReply_Closure)
                 (const UeConfigReply *message,
                  void *closure_data);
typedef void (*Configs_Closure)
                 (const Configs *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    config_msg_type__descriptor;
extern const ProtobufCEnumDescriptor    hopping_mode__descriptor;
extern const ProtobufCEnumDescriptor    phich_resource__descriptor;
extern const ProtobufCEnumDescriptor    phich_duration__descriptor;
extern const ProtobufCEnumDescriptor    ul_cyclic_prefix_length__descriptor;
extern const ProtobufCEnumDescriptor    dl_cyclic_prefix_length__descriptor;
extern const ProtobufCEnumDescriptor    duplex_mode__descriptor;
extern const ProtobufCEnumDescriptor    qam__descriptor;
extern const ProtobufCEnumDescriptor    meas_gap_pattern__descriptor;
extern const ProtobufCEnumDescriptor    setup_release_action__descriptor;
extern const ProtobufCEnumDescriptor    ue_transmission_antenna__descriptor;
extern const ProtobufCEnumDescriptor    aperiodic_cqi_report_mode__descriptor;
extern const ProtobufCEnumDescriptor    tdd_ack_nack_feedback_mode__descriptor;
extern const ProtobufCEnumDescriptor    layer_config__descriptor;
extern const ProtobufCMessageDescriptor enb_config_request__descriptor;
extern const ProtobufCMessageDescriptor ue_config_request__descriptor;
extern const ProtobufCMessageDescriptor sg_info_msg__descriptor;
extern const ProtobufCMessageDescriptor sg_info_config__descriptor;
extern const ProtobufCMessageDescriptor cell_phy_config__descriptor;
extern const ProtobufCMessageDescriptor cell_mac_config__descriptor;
extern const ProtobufCMessageDescriptor cell_rrc_config__descriptor;
extern const ProtobufCMessageDescriptor cell_config__descriptor;
extern const ProtobufCMessageDescriptor enb_config_reply__descriptor;
extern const ProtobufCMessageDescriptor drx_config__descriptor;
extern const ProtobufCMessageDescriptor sps_config__descriptor;
extern const ProtobufCMessageDescriptor sr_config__descriptor;
extern const ProtobufCMessageDescriptor cqi_config__descriptor;
extern const ProtobufCMessageDescriptor ue_capabilities__descriptor;
extern const ProtobufCMessageDescriptor scell_config__descriptor;
extern const ProtobufCMessageDescriptor ue_phy_config__descriptor;
extern const ProtobufCMessageDescriptor ue_mac_config__descriptor;
extern const ProtobufCMessageDescriptor ue_rrc_config__descriptor;
extern const ProtobufCMessageDescriptor ue_config__descriptor;
extern const ProtobufCMessageDescriptor ue_config_reply__descriptor;
extern const ProtobufCMessageDescriptor configs__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_configs_2eproto__INCLUDED */
